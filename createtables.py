import os
import subprocess
# this code modifies iptables.txt to create IP tables file to be restored by iptables-restore 

outputfile="newrules.txt"
commandsfile="ipcommands.sh"

# this function is not used!
def findips2(ipaddress:str):
    # we are making an IP scan on ethernet
    iparr=ipaddress.split(".")
    n_ip=iparr[0]+"."+iparr[1]+"."+iparr[2]+".0"
    proc = subprocess.Popen(["nmap -sN "+n_ip+"/24",""], stdout=subprocess.PIPE, shell=True)
    (p, err) = proc.communicate()
    returnedips=[]
    lines=p.decode('utf-8').split("\n")
    searched="Nmap scan report for "
    for line in lines:
        if searched in line:
            if "(" not in line and ")" not in line: # our own ip address is not added
                newip=line.replace(searched,"")
                returnedips.append(newip)
    return returnedips

# this function lists all the ips in every line.
# the source IP address is removed from the result at the end
def findips(ipaddress:str):
    iparr=ipaddress.split(".")
    n_ip=iparr[0]+"."+iparr[1]+"."+iparr[2]+".0"
    commandstr="nmap -sn "+n_ip+"/24 | awk '/Nmap scan/{gsub(/[()]/,\"\",$NF);print $NF}'"
    proc = subprocess.Popen([commandstr ,""], stdout=subprocess.PIPE, shell=True)
    (p, err) = proc.communicate()
    lines=p.decode('utf-8').split("\n")
    lines.remove(ipaddress) # we remove our own ipaddress
    # I didn't debug that much but sometimes empty line comes. 
    # I am removing the empty line
    lines.remove("")
    return lines
    
def getEthIP():
    proc = subprocess.Popen(["ifconfig" ,""], stdout=subprocess.PIPE, shell=True)
    (p, err) = proc.communicate()
    lines=p.decode('utf-8').split("\n")
    searched1="enp0"
    searched2="eth0"
    mode=False
    done=False
    ethip=""
    i=0
    while not done and  i < len(lines):
        line=lines[i]
        if not mode and searched1 in line or searched2 in line:
            mode=True ## until we find the the eth line continue to search for
        if mode:
            if "inet" in line:
                arr=line.split()
                ethip=arr[1]
                done=True # we break the loop
        i=i+1
    return ethip

def createinput(ports:str):
    allstr=[]
    allstr.append("-A INPUT -i eth0 -p tcp -m multiport --dports "+ports+" -m state --state NEW,ESTABLISHED -j ACCEPT\n")
    allstr.append("-A INPUT -i wlan0 -p tcp -m multiport --dports "+ports+" -m state --state NEW,ESTABLISHED -j ACCEPT\n")
    return allstr

def createoutput(ports:str):
    allstr=[]
    allstr.append("-A OUTPUT -o eth0 -p tcp -m multiport --sports "+ports+" -m state --state ESTABLISHED -j ACCEPT\n")
    allstr.append("-A OUTPUT -o wlan0 -p tcp -m multiport --sports "+ports+" -m state --state ESTABLISHED -j ACCEPT\n")
    return allstr

def createpre(ipaddr:str,portn:int):
    return "-A PREROUTING -i wlan0 -p tcp -m tcp --dport "+str(portn)+" -j DNAT --to-destination "+ipaddr+":80\n"

def createpost(ipaddr:str):
    return "-A POSTROUTING -d "+ipaddr+"/32 -p tcp -m tcp --dport 80 -j MASQUERADE\n"


# this is ethernet address
IPAddr=getEthIP()
if len(IPAddr) ==0:
    print("Couldnt find ethernet ip")
    exit()

postrouting=[]
prerouting=[]
ports=[]
portnum=8000
print("current device Ethernet IP :",IPAddr)

if IPAddr =="127.0.0.1":
    print("No ip set")
    exit()

ips=findips(IPAddr)
for ip in ips:
    portnum=portnum+1
    print("discovered ip address",ip)
    ports.append(str(portnum))
    prerouting.append(createpre(ip,portnum))
    postrouting.append(createpost(ip))


if len(ports)==0:
    print("no device detected")
    exit()

allports=",".join(ports)

f=open("iprules.txt","r")
fwr=open(outputfile,"w")
onlycommands=open(commandsfile,"w")


#we do not need  iprules.txt because we are only using the shell file we created now
# that shell file name is in commandsfile variable


onlycommands.write("#!/bin/bash\n")
onlycommands.write("## This file is auto generated by github library:iptablesGenerate\n")
alllines=f.readlines()
for line in alllines:
    if line == "####INPUTS####\n":
        fwr.write("####INPUTS#########\n")
        onlycommands.write("####INPUTS#########\n")
        c_arr=createinput(allports)
        for elem in c_arr:
            fwr.write(elem)
            onlycommands.write("sudo iptables --table filter "+elem)
        fwr.write("###################\n")
        onlycommands.write("###################\n")
    elif line == "####OUTPUTS####\n":
        fwr.write("####OUTPUTS########\n")
        onlycommands.write("####OUTPUTS#########\n")
        c_arr=createoutput(allports)
        for created in c_arr:
            fwr.write(created)
            onlycommands.write("sudo iptables --table filter "+created)
        fwr.write("###################\n")
        onlycommands.write("###################\n")
    elif line == "####PREROUTING####\n":
        fwr.write("####PREROUTING#####\n")
        onlycommands.write("###PREROUTING#####\n")
        for elem in prerouting:
            fwr.write(elem)
            onlycommands.write("sudo iptables --table nat "+elem)
        fwr.write("###################\n")
        onlycommands.write("###################\n")
    elif line == "####POSTROUTING####\n":
        fwr.write("####POSTROUTING####\n")
        onlycommands.write("####POSTROUTING####\n")
        for elem in postrouting:
            fwr.write(elem)
            onlycommands.write("sudo iptables --table nat "+elem)
        fwr.write("###################\n")
        onlycommands.write("###################\n")
    else:
         fwr.write(line)
f.close()
fwr.close()
onlycommands.close()
